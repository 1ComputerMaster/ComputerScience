# Network

## 1. CAP 이론

### 개요

- CAP 이론은 분산 시스템에서 (일관성)Consistency , (가용성) Availability, (분할 내성) Partition Tolerance 세 가지 특성 중 **두 가지만 보장** 할 수 있다는 이론.

### 용어 정의

**일관성 (Consistency)** : 

- 정의 : 모든 노드가 같은 시점에 같은 데이터를 가지고 있음
- 설명 : 클라이언트가 어느 노드에 접근하든 항상 최신의 동일한 데이터만 얻을 수 있다.

**가용성 (Availability)** :

- 정의 : 모든 요청에 대해서 항상 응답을 할 수 있음
- 설명 : 일부 노드에 장애가 발생하더라도 시스템은 정상적으로 동작하여 클라이언트의 요청에 응답해야 함.

**분할 내성 (Partition Tolerant)** :

- 정의 : 네트워크 분할이 발생하더라도 시스템이 정상적으로 동작함.
- 설명 : 네트워크 장애로 인해서 노드 간 통신이 불가능하더라도 시스템 전체가 중단되서는 안되고 일부 기능은 제공이 되어야 함

### 트레이드 오프

- 이론에 따르면 CAP 모두 완벽하게 통제 할 수 없으며 두가지는 만족하더라도 하나는 포기해야 합니다.

**CA 시스템 (일관성 + 가용성)** : 

- 특징 : 네트워크 분할이 없다는 가정하에 일관성과 가용성을 보장
- 문제점 : 현실적인 네트워크 환경에서는 분할 내성을 무시할 수 없음

**CP 시스템 (일관성 + 분할 내성)** :

- 특징 : 네트워크 분할 발생 시, 일관성 유지를 위해서 일부 요청에 대해서 응답을 포기
- 예시 : 분산 데이터베이스에서 노드 간 동기화가 완료될 때 까지 쓰기 요청을 막음
  - MongoDB : Primary Node에서만 Write가 일어나고 Operation log를 Secondary Node에서 읽어서 업데이트 하는 식으로 READ 정보는 Secondary에서 제공하는 역할을 할 수 있으며 이 때, Primary Node가 고장나면 Secondary Node중 가장 최근의 Operation log를 읽은 Node가 Primary Node가 되고 이것이 나머지 Secondary Node와 동기화 될 때까지는 Client가 Write Request를 수행 할 수 없지만 전체 Consistency는 유지가 됨 (CP) -> A는 희생

**AP 시스템 (가용성 + 분할 내성)** :

- 특징 : 네트워크 분할이 발생하더라도 가용성을 유지하기 위해서 데이터의 일관성을 포기
- 예시 : 최종 일관성을 제공하는 No SQL 데이터 베이스 
  - (Masterless 함)Cassandra의 경우 일관성을 포기하고 inconsistency한 데이터가 제공되나 이후에 reconcile 하는 방법으로 극복하려고 합니다. Available하나 Consistency 는 희생

## 2. 3-Way Handshake

> **정의** : TCP 프로토콜을 이용해 두 네트워크 장치 간에 통신 연결을 확립하기 위한 절차로, 신뢰성 있는 데이터 전송을 보장합니다.

#### 과정 
- 1. **SYN** : 클라이언트가 서버에서 연결 요청을 위해 SYN 패킷을 보냅니다.
- 2. **SYN-ACK** : 서버는 클라이언트의 요청을 받고, 연결 요청 수락을 위해 SYN-ACK 패킷을 보냅니다.
- 3. **ACK** : 클라이언트는 서버의 응답에 대한 확인을 위한 ACK를 보냅니다.

#### 특징 
- 3 단계를 거쳐 연결을 설정하고, 이후 데이터 전송이 시작됩니다. 이를 통해 데이터 전송 전에 양쪽이 서로 준비되었음을 보장합니다.

## 3. google Website 접속 과정

1. URL 입력 및 요청 생성 (응용 계층)
   - URL 입력 시 OSI 7 계층 중 응용 계층에서 HTTP 프로토콜 요청 메세지를 브라우저가 인식하여 생성

2. DNS Lookup (주소 결정 프로토콜, 응용 계층) 
    - 브라우저가 DNS를 IP주소로 매핑해야 하므로 DNS 조회를 수행합니다.
    1) 브라우저 캐시 : 브라우저는 먼저 이전에 있었던 도메인 정보를 가지고 최근에 접속한 도메인의 IP 주소를 캐시하고 있다면, 바로 해당 IP 주소를 매핑해서 사용합니다.
    2) 호스트 파일 : 운영체제의 host 파일을 확인합니다. (Window의 경우 System32/host.conf가 있었음)
    3) 시스템 DNS 캐시 : 브라우저 캐시에 없을 경우 OS Cache를 확인 해봅니다.
    4) DNS 서버 : 위 모든 단계에서 확인 불가시 ISP(Internet Service Provider)의 DNS 서버로 요청을 보냅니다. DNS 서버는 루트 네임 서버 -> 최상위 도메인(TLD) 서버 -> 권한 있는 네임서버 순서로 IP를 조회
       1) ISP의 DNS 서버 : 고객을 위해 DNS 서버를 자체적으로 운영하는데 이중에 www.google.com의 DNS 서버가 있으면 제공하나 없으면 루트 네임서버로 전달
       2) 루트 네임서버 : 13개의 루트 네임 서버 중 최상위 도메인 .com의 위치를 알고 있으므로 .com의 최상위 도메인 네임서버를 알려줍니다.
       3) 최상위 도메인 네임 서버 : TLD 네임 서버는 google.com의 네임 서버 정보를 제공합니다.
       4) 권한이 있는 네임서버 : IP 주소를 반환

3. TCP 연결 수립 (전송 계층)
   - IP 주소를 얻은 후 브라우저는 서버와 통신하기 위해 **TCP 연결**을 수립
   - **3-way Handshake** : TCP 신뢰성을 보장하기 위해 3Way handshake 수행
    1) SYN : 클라이언트가 서버에 연결 요청
    2) ACK-SYN : 서버는 연결을 확인하고 연결됨을 알려주기 위해서 SYN 전달
    3) ACK : 클라이언트도 응답을 확인하고 서버에게 연결을 확정 시켜줌
4. HTTPS의 경우
    1) 대칭키 전달을 통해서 암호화 통신을 위한 세션을 생성
5. HTTP 요청 전송 (세션 계층, 전송 계층, 네트워크 계층, 데이터 링크 계층)
    1) 세션 계층 : 연결 세션을 유지하면서 통신제어를 담당
    2) 전송 계층 : TCP 사용해서 데이터를 패킷으로 분할, 전송 중 손실된 데이터를 검증
    3) 네트워크 계층 : 패킷에 IP 주소를 할당해서 경로를 설정하고, 네트워크를 통해 패킷을 전달
    4) 데이터 링크 계층 : 실제 네트워크 장비를 통해서 패킷을 프레임에 담아 전기 신호나 무선 신호로 변환하여 전송
6. 패킷 전송
    1) 네트워크 계층 : IP 주소 기반으로 라우팅
    2) 데이터 링크 계층 : LAN에서의 MAC 주소를 사용해 네트워크 내에서 패킷을 전송
    3) 물리 계층 : 전기 신호, 무선 신호를 통해서 물리적으로 데이터를 전달
7. 서버에서 요청 처리 (응용 계층)
    - **웹 서버**에 도착한 패킷은 서버의 **프로토콜 스택**에 의해 재조립되어 HTTP 요청 메세지로 복원됨
    - **웹 서버 Application**이 응답 메세지 생성하여 HTTP로 전송
8. 동일한 방식으로 역방향으로 흐름
9. 브라우저 랜더링