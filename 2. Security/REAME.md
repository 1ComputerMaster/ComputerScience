# 보안
## 1. 네트워크 보안
### 1.1 SSL/TLS와 HTTPS

#### SSL/TLS의 역할:

데이터 암호화를 통해 통신 내용을 보호.
데이터 무결성을 보장하여 전송 중에 데이터가 변경되지 않도록 함.
인증서를 통해 서버의 신원을 확인.

#### HTTPS의 작동 원리:

> **SSL/TLS 핸드셰이크 과정**
>
>    - 클라이언트 헬로우: 클라이언트가 지원하는 프로토콜 버전, 암호화 방법 등을 서버에 전송.
>    - 서버 헬로우: 서버가 선택한 프로토콜 버전, 암호화 방법, 인증서를 클라이언트에 전송.
>    - 인증서 검증: 클라이언트가 서버의 인증서를 검증.
>    - 세션 키 생성: 대칭키를 생성하여 암호화된 방식으로 교환.
>    - 암호화 통신 시작: 이후의 통신은 대칭키로 암호화되어 전송.

### 1.2 CORS와 CSRF 공격 방지 방법
#### CORS (Cross-Origin Resource Sharing):

다른 도메인에서 리소스에 접근할 때 브라우저에서 이를 제한하는 정책.

**해결 방법**:
서버에서 Access-Control-Allow-Origin 헤더를 설정하여 허용할 도메인을 명시.

#### CSRF (Cross-Site Request Forgery):

사용자가 의도하지 않은 요청을 보내도록 속여서 권한이 없는 동작을 수행하게 만드는 공격.

**방지 방법**:
- CSRF 토큰 사용: 폼 제출 시 난수의 토큰을 포함하여 서버에서 검증.
- SameSite 쿠키 속성: 쿠키가 동일 사이트 요청에서만 전송되도록 설정.
- Referrer 검증: 요청의 Referrer 헤더를 확인하여 올바른 출처인지 확인.

## 2. 애플리케이션 보안
### 2.1 JWT (Json Web Token)을 통한 인증과 인가
#### JWT 구성:

- Header: 토큰 타입과 해싱 알고리즘 정보.
- Payload: 사용자 정보 및 클레임.
- Signature: Header와 Payload를 비밀키로 서명한 값.

**작동 원리**:

서버는 사용자가 로그인하면 JWT를 발급하여 클라이언트에 전달.
클라이언트는 이후 요청 시 JWT를 포함하여 서버에 전송.
서버는 JWT의 서명을 검증하여 사용자를 인증하고 권한을 확인.

**장점**:

- Stateless: 서버에서 세션을 저장하지 않아 확장성이 높음.
- 확장성: 마이크로서비스 아키텍처에서 서비스 간 인증에 유용.

**단점**:
토큰이 클라이언트에 저장되므로 탈취 시 위험.
토큰의 길이가 길어질 수 있음.

### 2.2 OAuth 2.0과 OpenID Connect
#### OAuth 2.0:

권한 위임을 위한 프로토콜로, 제3의 애플리케이션이 사용자 대신 리소스에 접근할 수 있도록 허용.

**주요 개념**:
- Resource Owner: 사용자.
- Client: 액세스를 요청하는 애플리케이션.
- Authorization Server: 인증 및 토큰 발급.
- Resource Server: 보호된 리소스가 있는 서버.

**OpenID Connect**:
OAuth 2.0 위에 사용자 인증을 위한 프로토콜을 추가한 것.
ID 토큰을 통해 사용자 정보를 전달하여 인증을 수행.