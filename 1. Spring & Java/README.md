# Spring & DB

### 1. Transaction (트랜잭션)

> **정의**: 데이터베이스에서 하나의 작업 단위로 실행되는 일련의 연산을 의미합니다. 트랜잭션은 데이터의 무결성과 일관성을 보장하기 위해 사용되며, 한 트랜잭션은 모두 커밋되거나 모두 실패해야 합니다.

#### ACID 특성
- **Atomicity (원자성)**: 트랜잭션은 모두 실패하거나 모두 성공해야 합니다. 중간에 실패하면 이전 연산도 모두 취소되어야 합니다.
- **Consistency (일관성)**: 트랜잭션이 완료되면 데이터베이스는 일관된 상태를 유지해야 합니다.
- **Isolation (고립성)**: 하나의 트랜잭션이 완료되기 전까지 다른 트랜잭션은 해당 트랜잭션이 변경하는 데이터에 접근할 수 없습니다.
- **Durability (지속성)**: 트랜잭션이 성공적으로 완료되면 해당 변경 사항은 영구적으로 저장되어야 합니다.

### 2. Lock (락)

> **정의** : 여러 트랜잭션이 동시에 같은 데이터에 접근 할 때 데이터의 일관성과 무결성을 유지하기 위해서 사용되는 매커니즘

#### 종류

- **Shared Lock (공유 락, S-Lock)** : 읽기 전용으로 여러 트랜잭션이 동시에 데이터에 접근할 수 있지만 수정은 불가능합니다.

- **Exclusive Lock (베타 락, X-Lock)** : 하나의 트랜잭션이 데이터에 접근하여 수정 할 수 있습니다. 다른 트랜잭션은 해당 데이터에 접근 불가능합니다. (Isolation (고립성) -> ACID)

#### 문제

- **Deadlock (교착 상태)** : 두 개 이상의 트랜잭션이 서로 Lock을 기다리면서 서로의 자원을 원하는 상태

#### 해결 방안

- **해결 방법** : 타임아웃, 락 우선 순위 부여, 데드락 감지 알고리즘 

### 3. Isolation Level (고립 수준)

> **정의** : 트랜잭션 간 격리 수준을 결정하는 설정으로, 데이터 일관성과 성능의 균형을 잡는데 사용됩니다.

#### 고립 수준의 종류

- **READ UNCOMMITTED** : 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있습니다. **Dirty Read** 문제가 발생 할 수 있습니다.

- **READ COMMITTED** : 커밋된 데이터만 읽을 수 있습니다. **Non-repeatable Read** 문제가 발생 할 수 있습니다.

- **REPEATABLE READ** : 한 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정 할 수 없습니다. **Phantom Read** 문제가 발생 할 수 있습니다.

- **SERIALIZABLE** : 가장 높은 수준의 고립 수준으로 모든 트랜잭션을 순차적으로 처리합니다. 모든 격리 문제를 방지하지만 성능이 저하됩니다.

### 4. Index (인덱스)

> **정의** : 데이터베이스의 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 자료구조

> **작동 방식** : 일반적으로 **B-Tree**와 같은 자료 구조를 사용하여 데이터 검색 속도로를 향상시킵니다.

#### 종류
- **Primary Index** : 테이블의 기본 키를 기준으로 하는 인덱스
- **Secondary Index** : 기본 키 외의 컬럼에 대해 생성하는 인덱스
- 
#### 장단점
- **장점** : 데이터 검색 속도가 빨라집니다.
- **단점** : 인덱스 생성 및 유지 비용이 발생하며, 인덱스가 많아질수록 데이터 삽입, 수정 삭제 시 성능 저하가 발생할 수 있습니다.

### 5. JPA N+1 문제

> **정의** : JPA에서 연관된 엔티티를 조회할 때 발생하는 성능 문제입니다.
> **상황** : 하나의 엔티티를 조회할 때 연관된 엔티티를 지연 로딩 (Lazy Loading) 설정으로 조회하면, 연관된 엔티티마다 추가적인 쿼리가 실행되어 성능이 저하됩니다.
> **예시** : 회원 리스트를 조회하면서 각 회원이 가진 주문 목록을 조회하는 경우, 회원 수가 N개라면 회원을 가져오는 1개의 쿼리와 각 회원의 주문 목록을 가져오는 N개의 쿼리로 총 N + 1개의 쿼리가 생성됩니다.

#### 해결 방법
- 패치 조인 (Fetch Join) : 연관된 엔티티를 한 번의 쿼리로 가져오는 방법
- 패치 조인 상세 : JOIN FETCH 문을 이용해서 이를 최적화 할 수 있습니다.
    ```
    String jpql = "SELECT m FROM Member m JOIN FETCH m.orders";
    List<Member> members = entityManager.createQuery(jpql, Member.class).getResultList(); //이렇게 설정하면 아래와 같이 쿼리를 만듭니다.

    SELECT m.*, o.*
    FROM member m
    LEFT JOIN order o ON m.id = o.member_id

    ```
- 엔티티 그래프 (Entity Graph) : 연관된 엔티티를 가져올 때 필요한 속성을 명시하는 방법 

### 6. DI (Dependency Injection, 의존성 주입)

> **정의** : Spring Framwork에서 볼 수 있는 특이한 패턴으로 객체 간의 의존 관계를 직접 설정하는 것이 아니라, 외부에서 필요한 객체를 주입하여 사용하도록 하는 디자인 패턴입니다.

#### 장점
- 코드 유지 보수가 용이하고 가독성이 높아집니다.
- 코드 결합도를 낮춰 유연성 및 테스트가 용이 해집니다.

#### 예시
- Spring Framework에서 생성자에 @Autowired 선언 후 final로 선언된 의존 객체에 대해서 의존성 주입을 시킵니다. 또는, Lombok의 @RequiredArgsConstructor을 씁니다. 보통 생성자 주입이 권장됩니다. 그 이유는 필드 주입 시 외부에서 해당 객체 접근이 불가능합니다. 보통 테스트 케이스 쓰기가 어렵습니다. 그리고, 서로가 서로의 객체를 바라보는 순환 참조 문제가 생길 수 있습니다.

### 7. AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)

> **정의** : 비즈니스 로직에서 공통적인 기능 (로깅, 보안, 트랜잭션 관리 등)을 분리하여 모듈화하고 재사용성을 높이기 위한 프로그래밍 패러다임 입니다.

#### 작동 방식
- **Aspect** : 공통 기능을 정의한 모듈
- **Advice** : 실제로 적용할 공통 기능 (로직)
- **Join Point** : Advice가 실행될 지점
- **Pointcut** : Advice를 적용할 조건

#### 장점 : 
중복된 코드를 줄일 수 있고, 비즈니스 로직과 공통 기능을 분리해 코드의 가독성과 유지보수를 향상 시킵니다.

### 8. Application Context (어플리케이션 컨텍스트)

> **정의** : Spring에서 빈(Bean) 객체를 관리하고 제공하는 컨테이너
#### 역할 
- 빈의 생성, 관리, 의존성 주입을 담당함
- 이벤트 전달, 메시지 리소스 핸들링, 환경 정보 등을 관리합니다.

### 9. 3-Way Handshake

> **정의** : TCP 프로토콜을 이용해 두 네트워크 장치 간에 통신 연결을 확립하기 위한 절차로, 신뢰성 있는 데이터 전송을 보장합니다.

#### 과정 
- 1. **SYN** : 클라이언트가 서버에서 연결 요청을 위해 SYN 패킷을 보냅니다.
- 2. **SYN-ACK** : 서버는 클라이언트의 요청을 받고, 연결 요청 수락을 위해 SYN-ACK 패킷을 보냅니다.
- 3. **ACK** : 클라이언트는 서버의 응답에 대한 확인을 위한 ACK를 보냅니다.

#### 특징 
- 3 단계를 거쳐 연결을 설정하고, 이후 데이터 전송이 시작됩니다. 이를 통해 데이터 전송 전에 양쪽이 서로 준비되었음을 보장합니다.

### 9. IoC 컨테이너란?
> **정의** : **IoC (Inversion of Control)**는 객체의 생성과 의존성 관리를 개발자가 직접 수행하는 대신, 프레임워크가 이를 맡아 처리한다는 개념입니다. Spring 프레임워크에서는 IoC 컨테이너가 이 역할을 수행합니다. 
> 
>  IoC 컨테이너는 애플리케이션에 필요한 객체(빈, Bean)를 생성하고, 이들 간의 의존성 주입(Dependency Injection)을 관리하는 핵심 구성 요소입니다. 이를 통해 개발자는 객체 생성과 의존성 관리에 대한 고민 없이 비즈니스 로직에 집중할 수 있습니다.

**IoC 컨테이너의 역할**

- **객체 생성**: 개발자가 직접 객체를 생성하는 것이 아니라, 컨테이너에 객체 생성 방법을 등록해 두면, 필요할 때 IoC 컨테이너가 해당 객체를 생성합니다.

- **의존성 관리**: 객체들 간의 의존 관계를 IoC 컨테이너가 설정합니다. 이를 통해 객체들은 서로 직접적인 의존성을 갖지 않고, 컨테이너를 통해 필요한 의존성을 주입받게 됩니다.

- **객체 수명 주기 관리**: 객체의 생성, 소멸 등 전체 생명 주기를 컨테이너가 관리합니다.

### 10. 빈(Bean)이란?
> **정의** : **빈(Bean)**은 IoC 컨테이너에 의해 생성되고 관리되는 객체를 의미합니다. Spring에서는 빈 객체를 XML, 자바 어노테이션(@Component, @Service, @Repository, @Controller) 또는 자바 설정 파일(@Configuration) 등을 통해 정의하고 관리합니다.
> 
> 빈은 싱글톤(Singleton) 패턴을 기본으로 사용하므로, 애플리케이션 실행 동안 빈을 하나만 생성하여 여러 곳에서 재사용할 수 있습니다. 이로 인해 메모리 효율성을 높이고 일관된 객체 상태를 유지할 수 있습니다.

**빈 생성과 의존성 주입 관리란?**
IoC 컨테이너를 사용해 빈을 생성하고 의존성을 주입하는 과정을 살펴보겠습니다:

#### 1. 빈 생성
Spring IoC 컨테이너는 개발자가 정의한 설정(@Component, @Service, @Repository, @Bean 등)에 따라 빈을 생성합니다. 예를 들어, 아래의 코드를 통해 Car 클래스가 빈으로 등록될 수 있습니다:

```java
@Component
public class Car {
    public void start() {
        System.out.println("Car is starting.");
    }
}
```

- 위 코드에서 @Component 어노테이션을 사용하면, Spring IoC 컨테이너는 Car 객체를 빈으로 자동 생성하여 관리합니다.

#### 2. 의존성 주입 (Dependency Injection)

- 의존성 주입이란 객체가 필요한 의존성을 IoC 컨테이너로부터 주입받는 것을 의미합니다. Spring에서는 @Autowired 어노테이션을 통해 의존성 주입을 간편하게 처리할 수 있습니다.

``` java

@Component
public class Garage {

    private final Car car;

    // 생성자 주입
    @Autowired
    public Garage(Car car) {
        this.car = car;
    }

    public void openGarage() {
        car.start();
        System.out.println("Garage is open.");
    }
}
```
- 위 코드에서 Garage 클래스는 Car 클래스에 의존하고 있습니다.

- @Autowired 어노테이션을 사용하면 Spring IoC 컨테이너가 Car 빈을 생성자에 주입해줍니다.

- 이렇게 하면 개발자는 직접 Car 객체를 생성하거나 관리할 필요가 없고, 대신 IoC 컨테이너가 Car 객체를 생성하여 Garage에 주입합니다.

#### 정리
- IoC 컨테이너는 객체의 생성 및 의존성을 관리하여 애플리케이션의 결합도를 낮춥니다.

- **빈(Bean)**은 IoC 컨테이너에 의해 생성 및 관리되는 객체이며, 재사용성을 높이고 상태 일관성을 유지합니다.

- 의존성 주입은 IoC 컨테이너가 객체 간의 의존성을 자동으로 연결해주는 것을 의미하며, 이는 개발자가 객체를 직접 생성하고 관리하는 부담을 덜어줍니다.

- 이를 통해 개발자는 객체 생성 및 의존성 관리에 신경 쓸 필요 없이 비즈니스 로직 구현에 집중할 수 있으며, 애플리케이션의 유연성과 유지보수성이 향상됩니다.