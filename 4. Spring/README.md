# Spring

### 1. DI (Dependency Injection, 의존성 주입)

> **정의** : Spring Framwork에서 볼 수 있는 특이한 패턴으로 객체 간의 의존 관계를 직접 설정하는 것이 아니라, 외부에서 필요한 객체를 주입하여 사용하도록 하는 디자인 패턴입니다.

#### 장점
- 코드 유지 보수가 용이하고 가독성이 높아집니다.
- 코드 결합도를 낮춰 유연성 및 테스트가 용이 해집니다.

#### 예시
- Spring Framework에서 생성자에 @Autowired 선언 후 final로 선언된 의존 객체에 대해서 의존성 주입을 시킵니다. 또는, Lombok의 @RequiredArgsConstructor을 씁니다. 보통 생성자 주입이 권장됩니다. 그 이유는 필드 주입 시 외부에서 해당 객체 접근이 불가능합니다. 보통 테스트 케이스 쓰기가 어렵습니다. 그리고, 서로가 서로의 객체를 바라보는 순환 참조 문제가 생길 수 있습니다.

### 2. AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)

> **정의** : 비즈니스 로직에서 공통적인 기능 (로깅, 보안, 트랜잭션 관리 등)을 분리하여 모듈화하고 재사용성을 높이기 위한 프로그래밍 패러다임 입니다.

#### 작동 방식
- **Aspect** : 공통 기능을 정의한 모듈
- **Advice** : 실제로 적용할 공통 기능 (로직)
- **Join Point** : Advice가 실행될 지점
- **Pointcut** : Advice를 적용할 조건

#### 장점 : 
중복된 코드를 줄일 수 있고, 비즈니스 로직과 공통 기능을 분리해 코드의 가독성과 유지보수를 향상 시킵니다.

### 3. Application Context (어플리케이션 컨텍스트)

> **정의** : Spring에서 빈(Bean) 객체를 관리하고 제공하는 컨테이너
#### 역할 
- 빈의 생성, 관리, 의존성 주입을 담당함
- 이벤트 전달, 메시지 리소스 핸들링, 환경 정보 등을 관리합니다.


### 4. IoC 컨테이너란?
> **정의** : **IoC (Inversion of Control)**는 객체의 생성과 의존성 관리를 개발자가 직접 수행하는 대신, 프레임워크가 이를 맡아 처리한다는 개념입니다. Spring 프레임워크에서는 IoC 컨테이너가 이 역할을 수행합니다. 
> 
>  IoC 컨테이너는 애플리케이션에 필요한 객체(빈, Bean)를 생성하고, 이들 간의 의존성 주입(Dependency Injection)을 관리하는 핵심 구성 요소입니다. 이를 통해 개발자는 객체 생성과 의존성 관리에 대한 고민 없이 비즈니스 로직에 집중할 수 있습니다.

**IoC 컨테이너의 역할**

- **객체 생성**: 개발자가 직접 객체를 생성하는 것이 아니라, 컨테이너에 객체 생성 방법을 등록해 두면, 필요할 때 IoC 컨테이너가 해당 객체를 생성합니다.

- **의존성 관리**: 객체들 간의 의존 관계를 IoC 컨테이너가 설정합니다. 이를 통해 객체들은 서로 직접적인 의존성을 갖지 않고, 컨테이너를 통해 필요한 의존성을 주입받게 됩니다.

- **객체 수명 주기 관리**: 객체의 생성, 소멸 등 전체 생명 주기를 컨테이너가 관리합니다.

### 5. 빈(Bean)이란?
> **정의** : **빈(Bean)**은 IoC 컨테이너에 의해 생성되고 관리되는 객체를 의미합니다. Spring에서는 빈 객체를 XML, 자바 어노테이션(@Component, @Service, @Repository, @Controller) 또는 자바 설정 파일(@Configuration) 등을 통해 정의하고 관리합니다.
> 
> 빈은 싱글톤(Singleton) 패턴을 기본으로 사용하므로, 애플리케이션 실행 동안 빈을 하나만 생성하여 여러 곳에서 재사용할 수 있습니다. 이로 인해 메모리 효율성을 높이고 일관된 객체 상태를 유지할 수 있습니다.

**빈 생성과 의존성 주입 관리란?**
IoC 컨테이너를 사용해 빈을 생성하고 의존성을 주입하는 과정을 살펴보겠습니다:

#### 1. 빈 생성
Spring IoC 컨테이너는 개발자가 정의한 설정(@Component, @Service, @Repository, @Bean 등)에 따라 빈을 생성합니다. 예를 들어, 아래의 코드를 통해 Car 클래스가 빈으로 등록될 수 있습니다:

```java
@Component
public class Car {
    public void start() {
        System.out.println("Car is starting.");
    }
}
```

- 위 코드에서 @Component 어노테이션을 사용하면, Spring IoC 컨테이너는 Car 객체를 빈으로 자동 생성하여 관리합니다.

#### 2. 의존성 주입 (Dependency Injection)

- 의존성 주입이란 객체가 필요한 의존성을 IoC 컨테이너로부터 주입받는 것을 의미합니다. Spring에서는 @Autowired 어노테이션을 통해 의존성 주입을 간편하게 처리할 수 있습니다.

``` java

@Component
public class Garage {

    private final Car car;

    // 생성자 주입
    @Autowired
    public Garage(Car car) {
        this.car = car;
    }

    public void openGarage() {
        car.start();
        System.out.println("Garage is open.");
    }
}
```
- 위 코드에서 Garage 클래스는 Car 클래스에 의존하고 있습니다.

- @Autowired 어노테이션을 사용하면 Spring IoC 컨테이너가 Car 빈을 생성자에 주입해줍니다.

- 이렇게 하면 개발자는 직접 Car 객체를 생성하거나 관리할 필요가 없고, 대신 IoC 컨테이너가 Car 객체를 생성하여 Garage에 주입합니다.

#### 정리
- IoC 컨테이너는 객체의 생성 및 의존성을 관리하여 애플리케이션의 결합도를 낮춥니다.

- **빈(Bean)**은 IoC 컨테이너에 의해 생성 및 관리되는 객체이며, 재사용성을 높이고 상태 일관성을 유지합니다.

- 의존성 주입은 IoC 컨테이너가 객체 간의 의존성을 자동으로 연결해주는 것을 의미하며, 이는 개발자가 객체를 직접 생성하고 관리하는 부담을 덜어줍니다.

- 이를 통해 개발자는 객체 생성 및 의존성 관리에 신경 쓸 필요 없이 비즈니스 로직 구현에 집중할 수 있으며, 애플리케이션의 유연성과 유지보수성이 향상됩니다.


### 6. API Gateway란?

- API Gateway는 MSA에서 클라이언트 요청을 적절한 서비스로 라우팅하고 공통 기능을 수행하기 위해서 만들어진 서비스

#### 역할

- **요청 라우팅** : 클라이언트 요청을 각 마이크로서비스로 전달

- **인증 및 권한 부여** : JWT Token 인증 시스템을 API Gateway에 구성하여 이를 공통으로 빼서 쓸 수 있습니다. JWT Token 검증 가능 또는, **Spring Security**의 권한에 따라서 요청을 필터링 합니다. Admin이면 Admin Page 접근등

- **요청 제한 및 모니터링** : 단위 시간당 요청 수를 제한하여 서비스 남용을 방지합니다. 트래픽 추적 및 에러 로그 수집 등으로 시스템 상태를 파악합니다.
  - 요청 제한 : 애초에 받을 때 부터 받을 수 있는 최대 Client 수를 지정해서 받는 것임 CircuitBreaker와는 다른 개념으로 서킷은 백엔드 서비스에서 다른 MSA 내부 서비스 장애 포인트로 연결되지 않게끔 Timeout 장애를 연쇄적으로 일으키는 것을 막는 것이고 Rate Limit와는 다름

- **캐싱 및 로드 밸런싱** : 자주 요청되는 데이터를 캐싱하여 성능을 향상 시키고 백엔드 서비스로 트래픽을 균등히 배분합니다. (Round Robin)
 - 여기서 의미하는 응답 캐싱은 AWS API GATEWAY 기능으로 사용 가능함
 - 스프링 Cloud에서 구현 하려면 API Gateway 구현 시 REDIS 연동 후 TTL 걸어서 가져오는 식으로 해야 할 것임

### 7 Service Discovery

#### 정의

- 서비스 디스커버리는 동적으로 변화하는 마이크로 서비스의 네트워크 위치(IP와 포트)를 찾을 수 있게 해주는 매커니즘
 

#### 원리

1. 서비스 레지스트리 : **서비스 레지스트리**는 각 서비스의 인스턴스의 네트워크 위치 정보를 기억하는 데이터베이스
 - Eureka 서버에서는 Inmemory 형태로 데이터 베이스를 기억하고 이를, JVM에 Heap 메모리에서 기억합니다. (기본형 객체가 아니니 당연히 Heap에 저장됨)

2. 서비스 등록 : 서비스 인스턴스 (User Service, Product Service, ...)가 시작 될 때, 서비스 레지스트리에 등록되고 헬스체크를 통해서 서비스 가용성을 지속적으로 확인 (Actuator)

3. 서비스 조회 : 클라이언트 또는 API Gateway가 서비스 레지스트리에서 목적 서비스의 위치를 조회함

#### 구현 방식

1. 클라이언트 사이드 디스커버리

- **클라이언트**가 서비스 레지스트리에서 직접 서비스 위치를 조회하고 요청을 전달.
- 로드 밸런싱을 클라이언트 측에서 연동 (Application 주도)

2. 서버 사이드 디스커버리

- 클라이언트 요청이 **로드 밸런서**로 전달이 되고 로드 밸런서가 서비스 레지스트리에서 위치를 조회해서 요청을 전달함 (Kubernetes -> Service 등록 시 해당 서비스의 포트 및 service name등으로 판단 가능)

