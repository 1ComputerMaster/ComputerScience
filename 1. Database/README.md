# Database

### 1. Transaction (트랜잭션)

> **정의**: 데이터베이스에서 하나의 작업 단위로 실행되는 일련의 연산을 의미합니다. 트랜잭션은 데이터의 무결성과 일관성을 보장하기 위해 사용되며, 한 트랜잭션은 모두 커밋되거나 모두 실패해야 합니다.

#### ACID 특성
- **Atomicity (원자성)**: 트랜잭션은 모두 실패하거나 모두 성공해야 합니다. 중간에 실패하면 이전 연산도 모두 취소되어야 합니다.
- **Consistency (일관성)**: 트랜잭션이 완료되면 데이터베이스는 일관된 상태를 유지해야 합니다.
- **Isolation (고립성)**: 하나의 트랜잭션이 완료되기 전까지 다른 트랜잭션은 해당 트랜잭션이 변경하는 데이터에 접근할 수 없습니다.
- **Durability (지속성)**: 트랜잭션이 성공적으로 완료되면 해당 변경 사항은 영구적으로 저장되어야 합니다.

### 2. Lock (락)

> **정의** : 여러 트랜잭션이 동시에 같은 데이터에 접근 할 때 데이터의 일관성과 무결성을 유지하기 위해서 사용되는 매커니즘

#### 종류

- **Shared Lock (공유 락, S-Lock)** : 읽기 전용으로 여러 트랜잭션이 동시에 데이터에 접근할 수 있지만 수정은 불가능합니다.

- **Exclusive Lock (베타 락, X-Lock)** : 하나의 트랜잭션이 데이터에 접근하여 수정 할 수 있습니다. 다른 트랜잭션은 해당 데이터에 접근 불가능합니다. (Isolation (고립성) -> ACID)

#### 문제

- **Deadlock (교착 상태)** : 두 개 이상의 트랜잭션이 서로 Lock을 기다리면서 서로의 자원을 원하는 상태

#### 해결 방안

- **해결 방법** : 타임아웃, 락 우선 순위 부여, 데드락 감지 알고리즘 

### 3. Isolation Level (고립 수준)

> **정의** : 트랜잭션 간 격리 수준을 결정하는 설정으로, 데이터 일관성과 성능의 균형을 잡는데 사용됩니다.

#### 고립 수준의 종류

- **READ UNCOMMITTED** : 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있습니다. **Dirty Read** 문제가 발생 할 수 있습니다.

- **READ COMMITTED** : 커밋된 데이터만 읽을 수 있습니다. **Non-repeatable Read** 문제가 발생 할 수 있습니다.
  - Non-repeatable Read : Transaction 내부에서 같은 쿼리를 실행해도 다른 값을 읽어오는 경우가 생길 수 있습니다. A 트랜잭션에서 T1(시간) 에 조회한 회원 정보가 B 트랜잭션 T2(시간) 에서 Update를 해버리면 A 트랜잭션에서 T3(시간) 를 한 번 더 조회하면 읽어 온 값이 달라집니다. 

- **REPEATABLE READ** : 한 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정 할 수 없습니다. **Phantom Read** 문제가 발생 할 수 있습니다.

- **SERIALIZABLE** : 가장 높은 수준의 고립 수준으로 모든 트랜잭션을 순차적으로 처리합니다. 모든 격리 문제를 방지하지만 성능이 저하됩니다.

### 4. Index (인덱스)

> **정의** : 데이터베이스의 테이블에서 데이터를 빠르게 검색할 수 있도록 도와주는 자료구조

> **작동 방식** : 일반적으로 **B-Tree**와 같은 자료 구조를 사용하여 데이터 검색 속도를 향상시킵니다.

#### 종류
- **Primary Index** : 테이블의 기본 키를 기준으로 하는 인덱스
- **Secondary Index** : 기본 키 외의 컬럼에 대해 생성하는 인덱스

#### 장단점
- **장점** : 데이터 검색 속도가 빨라집니다.
- **단점** : 인덱스 생성 및 유지 비용이 발생하며, 인덱스가 많아질수록 데이터 삽입, 수정 삭제 시 성능 저하가 발생할 수 있습니다.


### 5. Redis란 무엇인가?
> **정의** : Redis는 "Remote Dictionary Server"의 약자로, 오픈 소스 기반의 인메모리 데이터 구조 저장소입니다. 높은 성능을 제공하며, 키-값(key-value) 구조의 데이터를 메모리에 저장하고 관리합니다. 다양한 데이터 구조(문자열, 해시, 리스트, 셋, 정렬된 셋 등)를 지원하며, 캐싱, 세션 저장, 실시간 분석, 메시지 브로커 등 다양한 용도로 활용됩니다.

> **특징** : 다만, 레디스 서버의 인 메모리 데이터 베이스로 저장되므로 빠른 응답 대신 RAM 만큼의 용량을 가지기 때문에 적절한 TTL 사용 또는 압축 로직을 사용해서 용량을 최적화하여 사용해야 합니다.

### 6. PostgreSQL이란 무엇인가?
> **정의** : PostgreSQL은 오픈 소스 객체-관계형 데이터베이스 관리 시스템(ORDBMS)입니다. 1986년 캘리포니아 버클리 대학교에서 시작된 POSTGRES 프로젝트를 기반으로 하며, SQL 표준을 준수하면서도 확장성과 신뢰성이 높은 데이터베이스로 발전해 왔습니다.

**특징** 
- 오픈 소스 라이선스: 자유롭게 사용, 수정, 배포가 가능하며, 커뮤니티에 의해 지속적으로 개발되고 있습니다.
- 객체-관계형 모델: 전통적인 관계형 데이터베이스 기능뿐만 아니라 객체 지향적 요소(예: 사용자 정의 타입, 상속 등)를 지원합니다.

#### PostgreSQL의 주요 특징

**SQL 표준 준수**: ANSI/ISO SQL 표준을 대부분 지원하여 호환성이 높습니다.

**확장성**: 사용자가 함수를 정의하거나 데이터 타입을 확장할 수 있습니다.

#### 강력한 데이터 무결성

- ACID 트랜잭션 지원: 원자성, 일관성, 격리성, 지속성을 보장하는 트랜잭션을 제공합니다.
- 다양한 격리 수준: Serializable, Repeatable Read, **Read Committed**(Defalut), Read Uncommitted 등 다양한 격리 수준을 지원합니다.
- 외래 키, 도메인, 체크 제약조건: 데이터의 무결성을 유지하기 위한 다양한 제약조건을 제공합니다.

### 7. 일관성 수준

#### 1. 강한 일관성(Strong Consistency)
> **정의** : 강한 일관성은 데이터를 읽을 때 항상 가장 최근에 쓰여진 값을 반환하는 것을 보장하는 모델입니다. 즉, 클라이언트가 어떤 **데이터를 읽으면, 그 데이터는 반드시 가장 최신의 값**을 포함하고 있어야 합니다.

**특징**
 - 장점: 항상 최신 데이터를 보장하므로, 애플리케이션의 복잡도가 줄어듭니다.
 - 단점: 강한 일관성을 보장하려면 모든 노드가 최신 상태로 동기화될 때까지 쓰기/읽기 연산을 차단해야 하므로 성능과 가용성이 떨어질 수 있습니다. 특히, 네트워크 지연이나 장애 상황에서는 **큰 성능 저하**가 발생할 수 있습니다.

#### 2. 약한 일관성(Weak Consistency)
> **정의** : 약한 일관성에서는 쓰기 연산이 완료된 후 즉시 **다른 클라이언트가 최신 데이터를 읽는 것을 보장하지 않습니다.** 즉, 어떤 클라이언트가 데이터를 읽을 때, 최신 값일 수도 있고, 아닐 수도 있습니다.

**특징**
- 장점: 성능이 매우 높고, 트랜잭션 지연이 적습니다.
- 단점: 데이터의 최신성을 보장하지 않으므로, 특정 애플리케이션에서는 오류를 초래할 수 있습니다.

#### 3. 최종 일관성(Eventual Consistency)
> **정의** : 최종 일관성은 데이터를 읽을 때마다 반드시 최신 데이터를 반환하지는 않지만, 시간이 지나면 **결국 모든 복제본에 데이터가 동기화**된다는 것을 보장합니다. 최종 일관성 모델은 일시적인 불일치를 허용하지만, **결국 일관된 상태에 도달하는 것을 목표**로 합니다.

**특징**
- 장점: 성능과 가용성을 모두 유지하면서 일관성을 일정 부분 보장할 수 있습니다.
- 단점: 데이터의 최신성은 보장되지 않으므로, 특정 순간에는 오래된 데이터를 읽을 수 있습니다.
- Redis는 기본적으로 최종 일관성을 보장하는 시스템입니다. 마스터-슬레이브 구조에서 비동기 복제는 최종적으로 일관성을 유지하지만, 일시적으로 슬레이브에서 읽은 데이터는 최신이 아닐 수 있습니다.
